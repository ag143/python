## SQL and MySQL details

### SQL Details

We can usually divide SQL into four categories, namely DDL (Data Definition Language), DML (Data Manipulation Language), DQL (Data Query Language) and DCL (Data Control Language). DDL is mainly used to create, delete, and modify objects in the database, such as creating, deleting and modifying two-dimensional tables. The core keywords include `create`, `drop` and `alter`; DML is mainly responsible for data insertion, deletion and modification. Update, keywords include `insert`, `delete` and `update`; DQL is responsible for data query, the most important keyword is `select`; DCL is usually used to grant and recall permissions, the core keywords are `grant` and `revoke`.

> **Note**: SQL is a case-insensitive language. For the convenience of writing and identification, the following SQL is written in lowercase letters.

#### DDL (Data Definition Language)

Let's implement a database for a course selection system. The SQL shown below creates a database named `school` and five tables, namely the college table (`tb_college`), the student table (`tb_student`), the teacher table ( `tb_teacher`), course schedule (`tb_course`) and course selection record table (`tb_record`), in which there is a many-to-one relationship between students and teachers and colleges, courses and teachers are also many-to-one relationships, students and courses It is a many-to-many relationship, and the course selection record table is an intermediate table that maintains a many-to-many relationship between students and courses.

````SQL
-- delete a database named school if it exists
drop database if exists `school`;

-- Create a database named school and set the default character set and sorting method
create database `school` default character set utf8mb4 collate utf8mb4_general_ci;

-- switch to the school database context
use `school`;

-- create college table
create table `tb_college`
(
`col_id` int unsigned auto_increment comment 'Number',
`col_name` varchar(50) not null comment 'name',
`col_intro` varchar(500) default '' comment 'introduction',
primary key (`col_id`)
) engine=innodb auto_increment=1 comment 'College table';

-- create student table
create table `tb_student`
(
`stu_id` int unsigned not null comment 'Student ID',
`stu_name` varchar(20) not null comment 'name',
`stu_sex` boolean default 1 not null comment 'sex',
`stu_birth` date not null comment 'date of birth',
`stu_addr` varchar(255) default '' comment 'Origin',
`col_id` int unsigned not null comment 'The college you belong to',
primary key (`stu_id`),
constraint `fk_student_col_id` foreign key (`col_id`) references `tb_college` (`col_id`)
) engine=innodb comment 'student table';

-- create teacher table
create table `tb_teacher`
(
`tea_id` int unsigned not null comment 'Work ID',
`tea_name` varchar(20) not null comment 'name',
`tea_title` varchar(10) default 'teaching assistant' comment 'title',
`col_id` int unsigned not null comment 'The college you belong to',
primary key (`tea_id`),
constraint `fk_teacher_col_id` foreign key (`col_id`) references `tb_college` (`col_id`)
) engine=innodb comment 'Teacher table';

-- create a class schedule
create table `tb_course`
(
`cou_id` int unsigned not null comment 'Number',
`cou_name` varchar(50) not null comment 'name',
`cou_credit` int not null comment 'credits',
`tea_id` int unsigned not null comment 'teaching teacher',
primary key (`cou_id`),
constraint `fk_course_tea_id` foreign key (`tea_id`) references `tb_teacher` (`tea_id`)
) engine=innodb comment 'Class Schedule';

-- Create a course selection record sheet
create table `tb_record`
(
`rec_id` bigint unsigned auto_increment comment 'Course selection record number',
`stu_id` int unsigned not null comment 'Student ID',
`cou_id` int unsigned not null comment 'Course ID',
`sel_date` date not null comment 'Course selection date',
`score` decimal(4,1) comment 'Exam Score',
primary key (`rec_id`),
constraint `fk_record_stu_id` foreign key (`stu_id`) references `tb_student` (`stu_id`),
constraint `fk_record_cou_id` foreign key (`cou_id`) references `tb_course` (`cou_id`),
constraint `uk_record_stu_cou` unique (`stu_id`, `cou_id`)
) engine=innodb comment 'Course selection record';
````

There are several places in the above DDL that need to be emphasized:

- When creating a database, we specified that the default character set used by the database is `utf8mb4` (`utf-8` encoding with a maximum of `4` bytes) through `default character set utf8mb4`, we recommend using this character set, it is also The character set used by MySQL 8.x by default because it supports international encoding and can also store Emoji characters. You can view the character sets supported by MySQL and the default collation with the following command.

  ````SQL
  show character set;
  ````
  
```
  +----------+---------------------------------+---------------------+--------+
  | Charset  | Description                     | Default collation   | Maxlen |
  +----------+---------------------------------+---------------------+--------+
  | big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 |
  | dec8     | DEC West European               | dec8_swedish_ci     |      1 |
  | cp850    | DOS West European               | cp850_general_ci    |      1 |
  | hp8      | HP West European                | hp8_english_ci      |      1 |
  | koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    |      1 |
  | latin1   | cp1252 West European            | latin1_swedish_ci   |      1 |
  | latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 |
  | swe7     | 7bit Swedish                    | swe7_swedish_ci     |      1 |
  | ascii    | US ASCII                        | ascii_general_ci    |      1 |
  | ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 |
  | sjis     | Shift-JIS Japanese              | sjis_japanese_ci    |      2 |
  | hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   |      1 |
  | tis620   | TIS620 Thai                     | tis620_thai_ci      |      1 |
  | euckr    | EUC-KR Korean                   | euckr_korean_ci     |      2 |
  | koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 |
  | gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 |
  | greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 |
  | cp1250   | Windows Central European        | cp1250_general_ci   |      1 |
  | gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 |
  | latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 |
  | armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 |
  | utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 |
  | ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 |
  | cp866    | DOS Russian                     | cp866_general_ci    |      1 |
  | keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  |      1 |
  | macce    | Mac Central European            | macce_general_ci    |      1 |
  | macroman | Mac West European               | macroman_general_ci |      1 |
  | cp852    | DOS Central European            | cp852_general_ci    |      1 |
  | latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 |
  | utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 |
  | cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 |
  | utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 |
  | utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 |
  | cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 |
  | cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 |
  | utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 |
  | binary   | Binary pseudo charset           | binary              |      1 |
  | geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  |      1 |
  | cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   |      2 |
  | eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 |
  | gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |
  +----------+---------------------------------+---------------------+--------+
  41 rows in set (0.00 sec)
  ```

If you want to set the character set used by default when the MySQL service starts, you can modify the configuration of MySQL and add the following.

  ````INI
  [mysqld]
  character-set-server=utf8
  ````

- When creating a table, you can choose the underlying storage engine by yourself. MySQL supports a variety of storage engines, which can be viewed through the `show engines` command. The default storage engine used in MySQL 5.5 and later versions is InnoDB, which is the storage engine we recommend everyone to use (because it is more suitable for the needs of current Internet applications for high concurrency, performance, and transaction support), for the backward compatibility of SQL statements To be specific, we can specify the use of the InnoDB storage engine by `engine=innodb` after the closing parenthesis at the end of the table creation statement.

  ````SQL
  show engines\G
  ````

  ````
  **************************** 1. row ******************** ******
        Engine: InnoDB
       Support: DEFAULT
       Comment: Supports transactions, row-level locking, and foreign keys
  Transactions: YES
            XA: YES
    Savepoints: YES
  **************************** 2. row ******************** ******
        Engine: MRG_MYISAM
       Support: YES
       Comment: Collection of identical MyISAM tables
  Transactions: NO
            XA: NO
    Savepoints: NO
  **************************** 3. row ******************** ******
        Engine: MEMORY
       Support: YES
       Comment: Hash based, stored in memory, useful for temporary tables
  Transactions: NO
            XA: NO
    Savepoints: NO
  **************************** 4. row ******************** ******
        Engine: BLACKHOLE
       Support: YES
       Comment: /dev/null storage engine (anything you write to it disappears)
  Transactions: NO
            XA: NO
    Savepoints: NO
  **************************** 5. row ******************** ******
        Engine: MyISAM
       Support: YES
       Comment: MyISAM storage engine
  Transactions: NO
            XA: NO
    Savepoints: NO
  **************************** 6. row ******************** ******
        Engine: CSV
       Support: YES
       Comment: CSV storage engine
  Transactions: NO
            XA: NO
    Savepoints: NO
  **************************** 7. row ******************** ******
        Engine: ARCHIVE
       Support: YES
       Comment: Archive storage engine
  Transactions: NO
            XA: NO
    Savepoints: NO
  **************************** 8. row ******************** ******
        Engine: PERFORMANCE_SCHEMA
       Support: YES
       Comment: Performance Schema
  Transactions: NO
            XA: NO
    Savepoints: NO
  **************************** 9. row ******************** ******
        Engine: FEDERATED
       Support: NO
       Comment: Federated MySQL storage engine
  Transactions: NULL
            XA: NULL
    Savepoints: NULL
  9 rows in set (0.00 sec)
  ````
  
The following table makes a simple comparison of several commonly used data engines in MySQL.

  | Features | InnoDB | MRG_MYISAM | MEMORY | MyISAM |
  | ------------ | ------------ | ------------ | ------ | ----- - |
  | Storage Limit | Yes | No | Yes | Yes |
  | Transactions | Support | | | |
  | Lock Mechanism | Row Lock | Table Lock | Table Lock | Table Lock |
  | B-Tree Index | Supported | Supported | Supported | Supported |
  | Hash Index | | | Support | |
  | Full Text Search | Supported (5.6+) | | | Supported |
  | Cluster Index | Support | | | |
  | Data Cache | Support | | Support | |
  | Index Cache | Supported | Supported | Supported | Supported |
  | Data compressible | | | | Support |
  | Memory Usage | High | Low | Medium | Low |
  | Storage Usage | High | Low | | Low |
  | Bulk Insert Performance | Low | High | High | High |
  | Whether to support foreign keys | Support | | | |

  From the above comparison, we can see that InnoDB is the only storage engine that can support foreign keys, transactions and row locks, so we said earlier that it is more suitable for Internet applications, and in newer versions of MySQL, it is also the default storage engine engine.

- When defining the table structure and selecting the data type for each field, if you are not sure which data type is more suitable, you can use the MySQL help system to learn about the characteristics of each data type, the length and precision of the data and other related information.

  ````SQL
  ? data types
  ````

  ````
  You asked for help about help category: "Data Types"
  For more information, type 'help <item>', where <item> is one of the following
  topics:
     AUTO_INCREMENT
     BIGINT
     BINARY
     BIT
     BLOB
     BLOB DATA TYPE
     BOOLEAN
     CHAR
     CHAR BYTE
     DATE
     DATETIME
     DEC
     DECIMAL
     DOUBLE
     DOUBLE PRECISION
     ENUM
     FLOAT
     INT
     INTEGER
     LONGBLOB
     LONGTEXT
     MEDIUMBLOB
     MEDIUMINT
     MEDIUMTEXT
     SET DATA TYPE
     SMALLINT
     TEXT
     TIME
     TIMESTAMP
     TINYBLOB
     TINYINT
     TINYTEXT
     VARBINARY
     VARCHAR
     YEAR DATA TYPE
  ````

  ````SQL
  ?varchar
  ````

  ````
  Name: 'VARCHAR'
  Description:
  [NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATE
  collation_name]
  
  A variable-length string. M represents the maximum column length in
  characters. The range of M is 0 to 65,535. The effective maximum length
  of a VARCHAR is subject to the maximum row size (65,535 bytes, which is
  shared among all columns) and the character set used. For example, utf8
  characters can require up to three bytes per character, so a VARCHAR
  column that uses the utf8 character set can be declared to be a maximum
  of 21,844 characters. See
  http://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html.
  
  MySQL stores VARCHAR values as a 1-byte or 2-byte length prefix plus
  data. The length prefix indicates the number of bytes in the value. A
  VARCHAR column uses one length byte if values require no more than 255
  bytes, two length bytes if values may require more than 255 bytes.
  
  *Note*:
  
  MySQL follows the standard SQL specification, and does not remove
  trailing spaces from VARCHAR values.
  
  VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is the
  standard SQL way to define that a VARCHAR column should use some
  predefined character set. MySQL uses utf8 as this predefined character
  set. http://dev.mysql.com/doc/refman/5.7/en/charset-national.html.
  NVARCHAR is shorthand for NATIONAL VARCHAR.
  
  URL: http://dev.mysql.com/doc/refman/5.7/en/string-type-overview.html
  ```

In the selection of data types, two types of `VARCHAR` and `CHAR` are usually used to save string data. The former is usually called a variable-length string, while the latter is usually called a fixed-length string; for the InnoDB storage engine, row The storage format does not distinguish between fixed-length and variable-length columns, so there is no essential difference between the `VARCHAR` type and the `CHAR` type, and the latter is not necessarily better than the former. If you want to save a very large string, you can use the `TEXT` type; if you want to save a very large byte string, you can use the `BLOB` (binary large object) type. In MySQL, `TEXT` and `BLOB` respectively include `TEXT`, `MEDIUMTEXT`, `LONGTEXT` and `BLOB`, `MEDIUMBLOB`, `LONGBLOB` three different types, their main difference lies in the storage of data The maximum size is different. Floating point numbers can be stored in `FLOAT` or `DOUBLE` types. `FLOAT` is deprecated and may be removed in subsequent versions of MySQL. Instead, use the `DECIMAL` type to store fixed-point numbers. If you want to save time and date, the `DATETIME` type is better than the `TIMESTAMP` type, because the former can represent a larger range of time and date.

#### DML (Data Manipulation Language)

We add data to the table created above through the SQL as shown below.

````SQL
use school;

-- Insert college data
insert into `tb_college`
    (`col_name`, `col_intro`)
values
    ('School of Computer', 'The School of Computer Science established the computer major in 1958, the Department of Computer Science in 1981, and the School of Computer Science in 1998. In May 2005, in order to further integrate teaching and research resources, the school decided that the School of Computer and Software Administration The team merges and operates in a unified manner, and implements a model of independent operation of teaching and student management. The college consists of three departments: Department of Computer Science and Technology, Department of Internet of Things Engineering, Department of Computational Finance; two research institutes: Institute of Graphics and Graphics, Cyberspace Security Research Institute (established in 2015); three teaching experiment centers: Computer Basic Teaching Experiment Center, IBM Technology Center, and Computer Professional Experiment Center.'),
    ('School of Foreign Languages', 'School of Foreign Languages ​​has 7 teaching units and 6 undergraduate majors with a combination of arts and sciences; 1 first-level discipline doctorate award point, 3 second-level discipline doctorate award points, 5 first-level discipline master's degrees Degree authorization points, 5 secondary discipline master's degree authorization points, 5 master's professional authorization areas, and 2 master's degree (MTI) majors; there are more than 210 faculty members, including more than 80 professors and associate professors. More than 60% of the full-time teachers are teachers with doctoral degrees and those who are currently studying for doctoral degrees from prestigious universities in China and abroad.'),
    ('School of Economics and Management', 'The predecessor of the School of Economics is the Economics Department founded in 1905; the late economists Peng Dixian, Zhang Yujiu, Jiang Xuemo, Hu Jichuang, Tao Dayong, Hu Daiguang, and contemporary scholars Liu Shibai have taught or study.');

-- insert student data
insert into `tb_student`
    (`stu_id`, `stu_name`, `stu_sex`, `stu_birth`, `stu_addr`, `col_id`)
values
    (1001, 'Yang Guo', 1, '1990-3-4', 'Hunan Changsha', 1),
    (1002, 'Let me go', 1, '1992-2-2', 'Changsha, Hunan', 1),
    (1033, 'Wang Yuyan', 0, '1989-12-3', 'Chengdu, Sichuan', 1),
    (1572, 'Yue Buqun', 1, '1993-7-19', 'Shaanxi Xianyang', 1),
    (1378, 'Ji Yanran', 0, '1995-8-12', 'Sichuan Mianyang', 1),
    (1954, 'Lin Pingzhi', 1, '1994-9-20', 'Putian, Fujian', 1),
    (2035, 'Eastern Unbeaten', 1, '1988-6-30', null, 2),
    (3011, 'Lin Zhennan', 1, '1985-12-12', 'Putian, Fujian', 3),
    (3755, 'Xiang Shaolong', 1, '1993-1-25', 'Chengdu, Sichuan', 3),
    (3923, 'Yang Buhui', 0, '1985-4-17', 'Chengdu, Sichuan', 3);

-- insert teacher data
insert into `tb_teacher`
    (`tea_id`, `tea_name`, `tea_title`, `col_id`)
values
    (1122, 'Zhang Sanfeng', 'Professor', 1),
    (1133, 'Song Yuanqiao', 'Associate Professor', 1),
    (1144, 'Yang Xiao', 'Associate Professor', 1),
    (2255, 'Fan Yao', 'Associate Professor', 2),
    (3366, 'Wei Yixiao', default, 3);

-- insert course data
insert into `tb_course`
    (`cou_id`, `cou_name`, `cou_credit`, `tea_id`)
values
    (1111, 'Python programming', 3, 1122),
    (2222, 'Web Front-End Development', 2, 1122),
    (3333, 'operating system', 4, 1122),
    (4444, 'computer network', 2, 1133),
    (5555, 'Compilation principle', 4, 1144),
    (6666, 'Algorithms and Data Structures', 3, 1144),
    (7777, 'Business French', 3, 2255),
    (8888, 'Cost Accounting', 2, 3366),
    (9999, 'Auditing', 3, 3366);

-- Insert course selection data
insert into `tb_record`
    (`stu_id`, `cou_id`, `sel_date`, `score`)
values
    (1001, 1111, '2017-09-01', 95),
    (1001, 2222, '2017-09-01', 87.5),
    (1001, 3333, '2017-09-01', 100),
    (1001, 4444, '2018-09-03', null),
    (1001, 6666, '2017-09-02', 100),
    (1002, 1111, '2017-09-03', 65),
    (1002, 5555, '2017-09-01', 42),
    (1033, 1111, '2017-09-03', 92.5),
    (1033, 4444, '2017-09-01', 78),
    (1033, 5555, '2017-09-01', 82.5),
    (1572, 1111, '2017-09-02', 78),
    (1378, 1111, '2017-09-05', 82),
    (1378, 7777, '2017-09-02', 65.5),
    (2035, 7777, '2018-09-03', 88),
    (2035, 9999, '2019-09-02', null),
    (3755, 1111, '2019-09-02', null),
    (3755, 8888, '2019-09-02', null),
    (3755, 9999, '2017-09-01', 92);
````

> **Note**: The above `insert` statement uses the batch method to insert data, which is more efficient to insert data.

#### DQL (Data Query Language)

Next, we complete the query shown below.

````SQL
-- Query all information of all students
select * from `tb_student`;

-- Query student number, name and hometown (projection)
select `stu_id`, `stu_name`, `stu_addr` from `tb_student`;

-- Query the names and credits of all courses (projections and aliases)
select `cou_name` as course name, `cou_credit` as credits from `tb_course`;

-- Query the names and dates of birth of all female students (filtering)
select `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=0;

-- Query the names and dates of birth of female students whose native place is "Chengdu, Sichuan" (screening)
select `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=0 and `stu_addr`='Chengdu, Sichuan';

-- Search for students whose native place is "Chengdu, Sichuan" or whose gender is "girl"
select `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=0 or `stu_addr`='Chengdu, Sichuan';

-- Query the name, gender and date of birth of all post-80s students (screening)
select `stu_name`, `stu_sex`, `stu_birth` from `tb_student`
where `stu_birth`>='1980-1-1' and `stu_birth`<='1989-12-31';

select `stu_name`, `stu_sex`, `stu_birth` from `tb_student`
where `stu_birth` between '1980-1-1' and '1989-12-31';

-- Added: 1 and 0 representing gender are handled as "male" and "female"
select
    `stu_name` as name,
    if(`stu_sex`, 'male', 'female') as gender,
    `stu_birth` as date of birth
from `tb_student`
where `stu_birth` between '1980-1-1' and '1989-12-31';

select
    `stu_name` as name,
    case `stu_sex` when 1 then 'male' else 'female' end as gender,
    `stu_birth` as date of birth
from `tb_student`
where `stu_birth` between '1980-1-1' and '1989-12-31';

-- Query the name and credits of courses with more than 2 credits (screening)
select `cou_name`, `cou_credit` from `tb_course` where `cou_credit`>2;

-- Query the names and credits of courses whose credits are odd (filtering)
select `cou_name`, `cou_credit` from `tb_course` where `cou_credit`%2<>0;

select `cou_name`, `cou_credit` from `tb_course` where `cou_credit` mod 2<>0;

-- Query and select the student number of students who have selected 1111 courses with a score of more than 90 points (screening)
select `stu_id` from `tb_record` where `cou_id`=1111 and `score`>90;

-- Query the name and gender of the student named "Yang Guo"
select `stu_name`, `stu_sex` from `tb_student` where `stu_name`='Yang Guo';
    
-- Query the name and gender of the student with the last name "Yang" (fuzzy)
-- % - wildcard, which can match 0 or any number of characters
select `stu_name`, `stu_sex` from `tb_student` where `stu_name` like 'Yang%';

-- Query the names and genders of students whose last name is "Yang" (fuzzy)
-- _ - wildcard, which matches exactly one character
select `stu_name`, `stu_sex` from `tb_student` where `stu_name` like 'yang_';

-- Query the names and genders of students whose last name is "Yang" (fuzzy)
select `stu_name`, `stu_sex` from `tb_student` where `stu_name` like 'yang__';

-- Query the names of students with "bu" or "yan" in their names (fuzzy)
select `stu_name` from `tb_student` where `stu_name` like '%不%' or `stu_name` like '%yan%';

-- Rename "Yue Buqun" to "Yue Buyan" and compare the difference between the following two queries
update `tb_student` set `stu_name`='Yue Buyan' where `stu_id`=1572;

select `stu_name` from `tb_student` where `stu_name` like '% not%'
union
select `stu_name` from `tb_student` where `stu_name` like '%yan%';

select `stu_name` from `tb_student` where `stu_name` like '% not%'
union all
select `stu_name` from `tb_student` where `stu_name` like '%yan%';

-- Query the names of students whose last name is "Yang" or "Lin" (regular expression fuzzy query)
select `stu_name` from `tb_student` where `stu_name` regexp '[Yang Lin].{2}';

-- Query the names of students who have not entered their hometown (null value processing)
select `stu_name` from `tb_student` where `stu_addr` is null;

select `stu_name` from `tb_student` where `stu_addr` <=> null;

-- Query the name of the student whose hometown has been entered (null value processing)
select `stu_name` from `tb_student` where `stu_addr` is not null;

-- The following query finds nothing, three-valued logic --> true / false / unknown
select `stu_name` from `tb_student` where `stu_addr`=null or `stu_addr`<>null;

-- Query all dates of the student's course selection (remove duplicates)
select distinct `sel_date` from `tb_record`;

-- Query the student's hometown (remove duplicates)
select distinct `stu_addr` from `tb_student` where `stu_addr` is not null;

-- Query the names and birthdays of male students in descending order of age (sort)
-- Ascending: Smallest to Largest - asc, Descending: Largest to Smallest - desc
select `stu_id`, `stu_name`, `stu_birth` from `tb_student`
where `stu_sex`=1 order by `stu_birth` asc, `stu_id` desc;

-- Supplement: Convert the above birthday to age (date function, numerical function)
select
    `stu_id` as student ID,
    `stu_name` as name,
    floor(datediff(curdate(), `stu_birth`)/365) as age
from `tb_student`
where `stu_sex`=1 order by age desc, `stu_id` desc;

-- Query the date of birth of the oldest student (aggregate function)
select min(`stu_birth`) from `tb_student`;

-- Query the birth date of the youngest student (aggregate function)
select max(`stu_birth`) from `tb_student`;

-- Query the highest score of the exam score of the course numbered 1111 (aggregation function)
select max(`score`) from `tb_record` where `cou_id`=1111;

-- Query the lowest score of the test score of the student whose student number is 1001 (aggregation function)
select min(`score`) from `tb_record` where `stu_id`=1001;

-- Query the average score of the test scores of students whose student number is 1001 (aggregation function)
select avg(`score`) from `tb_record` where `stu_id`=1001;

select sum(`score`) / count(`score`) from `tb_record` where `stu_id`=1001;

-- Query the average score of the test scores of students whose student number is 1001. If there is a null value, the null value will be counted as 0 (aggregation function)
select sum(`score`) / count(*) from `tb_record` where `stu_id`=1001;

select avg(ifnull(`score`, 0)) from `tb_record` where `stu_id`=1001;

-- Query the standard deviation of the test scores of students whose student number is 1001 (aggregation function)
select std(`score`), variance(`score`) from `tb_record` where `stu_id`=1001;

-- Query the number of male and female students (grouping and aggregation functions)
select
    case `stu_sex` when 1 then 'male' else 'female' end as gender,
    count(*) as number of people
from `tb_student` group by `stu_sex`;

-- Query the number of students in each college (grouping and aggregation functions)
select
    `col_id` as college,
    count(*) as number of people
from `tb_student` group by `col_id` with rollup;

-- Query the number of male and female students in each college (grouping and aggregation functions)
select
    `col_id` as college,
    if(`stu_sex`, 'male', 'female') as gender,
    count(*) as number of people
from `tb_student` group by `col_id`, `stu_sex`;

-- Query the student number and average grade of each student (grouping and aggregation functions)
select
    `stu_id`,
    round(avg(`score`), 1) as avg_score
from `tb_record` group by `stu_id`;

-- Query the student number and average grade of students whose average grade is greater than or equal to 90
-- The where clause is used for filtering before grouping, and the having clause is used for filtering after grouping
select
    `stu_id`,
    round(avg(`score`), 1) as avg_score
from `tb_record`
group by `stu_id` having avg_score>=90;

-- Query the student numbers and average grades of students whose average grades in courses 1111, 2222, and 3333 are greater than or equal to 90
select
    `stu_id`,
    round(avg(`score`), 1) as avg_score
from `tb_record` where `cou_id` in (1111, 2222, 3333)
group by `stu_id` having avg_score>=90;

-- Query the name of the oldest student (subquery/nested query)
-- Nested queries: use the results of one select as part of another select
select `stu_name` from `tb_student`
where `stu_birth`=(
    select min(`stu_birth`) from `tb_student`
);

-- Query the names of students who have chosen more than two courses (subquery/group condition/set operation)
select `stu_name` from `tb_student`
where `stu_id` in (
    select `stu_id` from `tb_record`
    group by `stu_id` having count(*)>2
);

-- Query student's name, birthday and college name
select `stu_name`, `stu_birth`, `col_name`
from `tb_student`, `tb_college`
where `tb_student`.`col_id`=`tb_college`.`col_id`;

select `stu_name`, `stu_birth`, `col_name`
from `tb_student` inner join `tb_college`
on `tb_student`.`col_id`=`tb_college`.`col_id`;

select `stu_name`, `stu_birth`, `col_name`
from `tb_student` natural join `tb_college`;

-- Query student name, course name and grades (connection query/join query)
select `stu_name`, `cou_name`, `score`
from `tb_student`, `tb_course`, `tb_record`
where `tb_student`.`stu_id`=`tb_record`.`stu_id`
and `tb_course`.`cou_id`=`tb_record`.`cou_id`
and `score` is not null;

select `stu_name`, `cou_name`, `score` from `tb_student`
inner join `tb_record` on `tb_student`.`stu_id`=`tb_record`.`stu_id`
inner join `tb_course` on `tb_course`.`cou_id`=`tb_record`.`cou_id`
where `score` is not null;

select `stu_name`, `cou_name`, `score` from `tb_student`
natural join `tb_record`
natural join `tb_course`
where `score` is not null;

-- Supplement: The above query results take the first 5 pieces of data (paging query)
select `stu_name`, `cou_name`, `score`
from `tb_student`, `tb_course`, `tb_record`
where `tb_student`.`stu_id`=`tb_record`.`stu_id`
and `tb_course`.`cou_id`=`tb_record`.`cou_id`
and `score` is not null
order by `score` desc
limit 0,5;

-- Supplement: The above query results take the 6-10 data (paging query)
select `stu_name`, `cou_name`, `score`
from `tb_student`, `tb_course`, `tb_record`
where `tb_student`.`stu_id`=`tb_record`.`stu_id`
and `tb_course`.`cou_id`=`tb_record`.`cou_id`
and `score` is not null
order by `score` desc
limit 5 offset 5;

-- Supplement: The above query results take the 11-15 data (paging query)
select `stu_name`, `cou_name`, `score`
from `tb_student`, `tb_course`, `tb_record`
where `tb_student`.`stu_id`=`tb_record`.`stu_id`
and `tb_course`.`cou_id`=`tb_record`.`cou_id`
and `score` is not null
order by `score` desc
limit 5 offset 10;

-- Query the names and average grades of students enrolled in courses (sub-query and join query)
select `stu_name`, `avg_score`
from `tb_student` inner join (
    select `stu_id` as `sid`, round(avg(`score`), 1) as avg_score
    from `tb_record` group by `stu_id`
) as `t2` on `stu_id`=`sid`;

-- Query the student's name and the number of courses selected
select `stu_name`, `total` from `tb_student` as `t1`
inner join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;

-- Query each student's name and number of courses (left outer join and subquery)
-- Left outer join: Each record in the left table (the table written on the left side of the join) can be checked out, and nulls are filled in places that do not meet the table join conditions.
select `stu_name`, coalesce(`total`, 0) as `total`
from `tb_student` as `t1`
left outer join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;

-- Modify the course selection record table and remove the foreign key constraint on the stu_id column
alter table `tb_record` drop foreign key `fk_record_stu_id`;

-- Insert two new records (note: there is no student with student number 5566)
insert into `tb_record`
values
    (default, 5566, 1111, '2019-09-02', 80),
    (default, 5566, 2222, '2019-09-02', 70);

-- Right outer join: Each record in the right table (the table written on the right side of the join) can be checked out, and nulls are filled in places that do not meet the table join conditions.
select `stu_name`, `total` from `tb_student` as `t1`
right outer join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;

-- Full outer join: Each record in the left table and the right table can be found out, and nulls are filled in places that do not meet the table connection conditions.
-- Note: MySQL does not support full outer joins, so it is represented by the union of left outer joins and right outer joins.
select `stu_name`, `total`
from `tb_student` as `t1`
left outer join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`
union
select `stu_name`, `total` from `tb_student` as `t1`
right outer join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;
````

The above DML has a few places that need to be explained:

1. The current version of MySQL does not support full outer join. Above, we use the `union` operation to combine the results of left outer join and right outer join to achieve the effect of full outer join. You can use the following figure to deepen your understanding of the operation of connecting tables.

   <img src="https://gitee.com/jackfrued/mypic/raw/master/20211121135117.png" style="zoom:50%">

2. MySQL supports multiple types of operators, including: arithmetic operators (`+`, `-`, `*`, `/`, `%`), comparison operators (`=`, `<> `, `<=>`, `<`, `<=`, `>`, `>=`, `BETWEEN...AND..`., `IN`, `IS NULL`, `IS NOT NULL `, `LIKE`, `RLIKE`, `REGEXP`), logical operators (`NOT`, `AND`, `OR`, `XOR`) and bitwise operators (`&`, `|`, `^ `, `~`, `>>`, `<<`), we can use these operators in DML to process data.

3. When querying data, you can use functions in the `SELECT` statement and its clauses (such as `WHERE` clause, `ORDER BY` clause, `HAVING` clause, etc.), these functions include string functions, Numeric functions, time and date functions, process functions, etc., as shown in the following table.

   Common string functions.

   | function | function |
   | ------------------------------------- | --------------------- -------------------------------- |
   | `CONCAT` | Concatenates multiple strings into one string |
   | `FORMAT` | Formats a number as a string with a specified number of decimal places |
   | `FROM_BASE64` / `TO_BASE64` | BASE64 decode/encode |
   | `BIN` / `OCT` / `HEX` | Convert numbers to binary/octal/hexadecimal strings |
   | `LOCATE` | Find the position of a substring in a string |
   | `LEFT` / `RIGHT` | Returns a string with left/right characters of the specified length |
   | `LENGTH` / `CHAR_LENGTH` | Returns the length of the string in bytes/characters |
   | `LOWER` / `UPPER` | Returns the lower/uppercase form of the string |
   | `LPAD` / `RPAD` | If the length of the string is insufficient, pad the specified characters on the left/right of the string |
   | `LTRIM` / `RTRIM` | Strip spaces before/after a string |
   | `ORD` / `CHAR` | Returns the code corresponding to the character / returns the character corresponding to the code |
   | `STRCMP` | Compare strings, return -1, 0, 1 for less than, equal to, greater than |
   | `SUBSTRING` | Returns a substring of the specified range of strings |

   Commonly used numerical functions.

   | function | function |
   | ------------------------------------------------- ------- | ---------------------------------- |
   | `ABS` | Returns the absolute value of a number |
   | `CEILING` / `FLOOR` | Returns a round up/down result |
   | `CONV` | Convert a number from one base to another |
   | `CRC32` | Calculate cyclic redundancy check code |
   | `EXP` / `LOG` / `LOG2` / `LOG10` | Calculate Exponential/Logarithm |
   | `POW` | exponentiation |
   | `RAND` | Returns a random number in the range [0,1) |
   | `ROUND` | Returns a rounded number |
   | `SQRT` | Returns the square root of a number |
   | `TRUNCATE` | Truncates a number to the specified precision |
   | `SIN` / `COS` / `TAN` / `COT` / `ASIN` / `ACOS` / `ATAN` | Trigonometric Functions |

   Common time and date functions.

   | function | function |
   | ----------------------------- | ------------------- ------------------ |
   | `CURDATE` / `CURTIME` / `NOW` | Get current date/time/date and time |
   | `ADDDATE` / `SUBDATE` | Add/subtract two date expressions and return the result |
   | `DATE` / `TIME` | Get date/time from string |
   | `YEAR` / `MONTH` / `DAY` | get year/month/day from date |
   | `HOUR` / `MINUTE` / `SECOND` | Get hours/minutes/seconds from time |
   | `DATEDIFF` / `TIMEDIFF` | Returns the difference in days/hours between two date expressions |
   | `MAKEDATE` / `MAKETIME` | Make a date/time |

   Common process functions.

   | function | function |
   | -------- | ---------------------------------------- -------- |
   | `IF` | Returns a different value depending on whether the condition is true |
   | `IFNULL` | Returns the specified value if NULL otherwise returns itself |
   | `NULLIF` | Returns NULL if the two expressions are equal otherwise returns the value of the first expression |

   Other commonly used functions.

   | function | function |
   | -------------------------------------- | ---------------------- ------- |
   | `MD5` / `SHA1` / `SHA2` | Returns the hash digest corresponding to the string |
   | `CHARSET` / `COLLATION` | Returns character set/collation rules |
   | `USER` / `CURRENT_USER` | Returns the current user |
   | `DATABASE` | Returns the current database name |
   | `VERSION` | Returns the current database version |
   | `FOUND_ROWS` / `ROW_COUNT` | Returns the number of rows queried/affected |
   | `LAST_INSERT_ID` | Returns the value of the last auto-incrementing primary key |
   | `UUID` / `UUID_SHORT` | Returns a globally unique identifier |

#### DCL (Data Control Language)

Data control language is used to authorize specified users or recall specified permissions from specified users. This group of operations is more important for database administrators.
````SQL
-- Create an account named wangdachui and assign it a password to allow access from any host
create user 'wangdachui'@'%' identified by '123456';

-- Authorize wangdachui to perform select and insert operations on the database named school
grant select, insert on `school`.* to 'wangdachui'@'%';

-- Recall wangdachui's insert permission to the school database
revoke insert on `school`.* from 'wangdachui'@'%';
````

> **Note**: Creating a user who can allow any host to log in and has super administrator privileges is not a wise decision in reality, because once the password of the account is leaked or cracked, the database will face a disaster level risk.

### MySQL details

#### index

Indexes are the most important means for improving query performance in relational databases. An index in a relational database is like a directory of a book. We can imagine that if we want to find out a certain knowledge point from a book, but this book has no directory, what a terrible thing it will be! We estimate that we have to go through it one by one to determine where this knowledge point is. Although creating an index will bring storage space overhead, just like a book's table of contents will occupy a part of the page, but the reduction in query time after sacrificing space is also very significant.

Columns of all data types in a MySQL database can be indexed. For the MySQL 8.0 version of the InnoDB storage engine, it supports three types of indexes, namely B+ tree indexes, full-text indexes, and R-tree indexes. Here, we only introduce the most widely used B+ tree indexes. The reason for using a B+ tree is very simple, because it is currently the most efficient data structure for disk-based storage and sorting of massive data. A B+ tree is a [balanced tree](https://zh.wikipedia.org/zh-cn/%E5%B9%B3%E8%A1%A1%E6%A0%91), the height of the tree is usually 3 Or 4, but it can save data from millions to billions, and querying a piece of data from these data requires only 3 or 4 I/O operations.

A B+ tree consists of a root node, intermediate nodes and leaf nodes, where the leaf nodes are used to store sorted data. Since the records are sorted on the index, binary search can be used when searching for data in a leaf node, which is very efficient. When there is very little data, the B+ tree has only one root node, and the data is stored on the root node. With more and more records, the B+ tree will split, and the root node no longer saves data, but provides a pointer to access the next layer of nodes, helping to quickly determine which leaf node the data is on.

When creating a two-dimensional table, we usually specify a primary key column for the table, and an index is created by default on the primary key column. For the MySQL InnoDB storage engine, because it uses the data storage structure of an index-organized table, the primary key The index is the data of the entire table, and this kind of index is also called **clustered index** (clustered index). Obviously, a table can only have one clustered index, otherwise the data of the table will be saved many times. The indexes we create ourselves are all secondary indexes, more commonly known as non-clustered indexes. Through our custom non-clustered index, only the primary key of the record can be located. When obtaining data, it may be necessary to query through the clustered index on the primary key. This phenomenon is called "return table". Therefore, retrieving data through a non-clustered index is usually faster than Retrieving data using a clustered index is slower.

Next, we will use a simple example to illustrate the meaning of indexing. For example, we need to find students based on their names. This scenario should be often encountered in actual development, which is the same as finding products by product names. We can use MySQL's `explain` keyword to view the SQL execution plan (the specific steps that the database executes the SQL statement).

````SQL
explain select * from tb_student where stuname='Lin Zhennan'\G
````

````
**************************** 1. row ******************** ******
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 11
     filtered: 10.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
````

In the above SQL execution plan, there are several items worth our attention:

1. `select_type`: The type of query.
    - `SIMPLE`: Simple SELECT, without using UNION operations or subqueries.
    - `PRIMARY`: If the query contains subqueries, the outermost SELECT is marked as PRIMARY.
    - `UNION`: The second or subsequent SELECT statement in a UNION operation.
    - `SUBQUERY`: The first SELECT in a subquery.
    - `DERIVED`: SELECT subqueries for derived tables.
2. `table`: query the corresponding table.
3. `type`: The way MySQL finds rows that meet the conditions in the table, also known as the access type, including: `ALL` (full table scan), `index` (index full scan, only traverse the index tree), ` range` (index range scan), `ref` (non-unique index scan), `eq_ref` (unique index scan), `const` / `system` (const-level query), `NULL` (no table or index access required ). Of all the access types, ALL is obviously the worst performing, and it represents a full table scan that scans every row in the table to find a matching row.
4. `possible_keys`: MySQL can select indexes, but **may not use**.
5. `key`: The index actually used by MySQL, if it is `NULL`, it means that no index is used.
6. `key_len`: The length of the index used, the shorter the length, the better without affecting the query.
7. `rows`: The number of rows that need to be scanned to execute the query, which is an **estimated value**.
8. `extra`: extra information about the query.
    - `Using filesort`: MySQL cannot use the index to complete the sorting operation.
    - `Using index`: Only use index information without further table lookup to get more information.
    - `Using temporary`: MySQL needs to use temporary tables to store result sets, which are often used for grouping and sorting.
    - `Impossible where`: The `where` clause results in no rows matching the condition.
    - `Distinct`: MySQL stops searching for more rows for the current row combination after finding the first matching row.
    - `Using where`: The query column is not covered by the index, and the filter condition is not the leading column of the index.

As can be seen from the above execution plan, when we query students by their names, we actually perform a full table scan. It goes without saying that the performance of this query must be very bad, especially when there are many rows in the table. If we often need to query students by their names, we should create an index on the column corresponding to the student's name to speed up the query through the index.

````SQL
create index idx_student_name on tb_student(stuname);
````

View the execution plan corresponding to the SQL just now.

````SQL
explain select * from tb_student where stuname='Lin Zhennan'\G
````

````
**************************** 1. row ******************** ******
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 62
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
````

It can be noticed that after creating an index on the student's name, the query just now is not a full table scan but an index-based query, and the scanned row is only one row, which obviously greatly improves the performance of the query. MySQL also allows to create a prefix index, that is to create an index on the first N characters of the index field, which can reduce the space occupied by the index (but saving space is likely to waste time, ** time and space are irreconcilable contradictions **),As follows.

````SQL
create index idx_student_name_1 on tb_student(stuname(1));
````

The above index is equivalent to an index created based on the first word of the student's name. Let's take a look at the SQL execution plan.

````SQL
explain select * from tb_student where stuname='Lin Zhennan'\G
````

````
**************************** 1. row ******************** ******
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 5
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
````

I don’t know if you have noticed that the rows scanned this time have become 2 rows, because there are two students with the surname “Lin” in the student table. If we only use the first word of the name as an index, we can pass the index when querying. will find these two lines.

If you want to drop the index, you can use the following SQL.

````SQL
alter table tb_student drop index idx_student_name;
````

or

````SQL
drop index idx_student_name on tb_student;
````

When creating an index, we can also use compound indexes and functional indexes (supported since MySQL 5.7). Using compound indexes to achieve **index coverage** can reduce unnecessary sorting and table return operations, which will improve the performance of the query. It has been doubled, and interested readers can study it by themselves.

We briefly summarize the design principles of the index for you:

1. **The most suitable columns for indexing are the columns that appear in the WHERE clause and join clause.
2. The larger the cardinality of the index column (more values ​​and fewer duplicate values), the better the indexing effect.
3. Using **prefix index** can reduce the space occupied by the index, and more indexes can be cached in memory.
4. **The more indexes the better**, although the index speeds up the read operation (query), the write operation (add, delete, modify) will become slower, because the change of the data will lead to the update of the index, just Just like the addition or deletion of chapters in a book, the table of contents needs to be updated.
5. When using the InnoDB storage engine, the ordinary index of the table will save the value of the primary key, so the primary key should be as short as possible. This can effectively reduce the space occupied by the index and improve the caching effect of the index.

Finally, there is one more point that needs to be explained. In the B-tree index used by InnoDB, the index of the numeric type column will take effect in addition to the equal value judgment. Use `>`, `<`, `>=`, `<=`, `BETWEEN...AND...`, `<>`, the index still works; for string type columns, if you use a fuzzy query that does not start with a wildcard, the index also works, but other situations will cause The index is invalid, which means that a full table query is likely to be done.

#### view

A view is an object in a relational database that combines a result set composed of a set of query instructions into a queryable data table. Simply put, a view is a virtual table, but unlike a data table, a data table is an entity structure, and a view is a virtual structure. You can also understand a view as an SQL that is stored in the database and given a name statement.

Use views to get the following benefits:

1. The entity data table can be hidden, so that external programs cannot know the actual data structure, allowing visitors to use the components of the table instead of the entire table, reducing the risk of database attacks.
2. In most cases, the view is read-only (the operation of updating the view usually has many restrictions), and the external program cannot directly modify the data through the view.
3. Reuse SQL statements, wrap highly complex queries in view tables, and directly access the view to retrieve the required data; views can also be viewed as data tables for connection queries.
4. The view can return data in a different format from the entity data table, and the data can be formatted when the view is created.

Create a view.

````SQL
-- create a view
create view `vw_avg_score`
as
    select `stu_id`, round(avg(`score`), 1) as `avg_score`
    from `tb_record` group by `stu_id`;

-- create a view based on an existing view
create view `vw_student_score`
as
    select `stu_name`, `avg_score`
    from `tb_student` natural join `vw_avg_score`;
````

> **Tip**: Because views do not contain data, every time you use a view, you must execute a query to get the data. If you use join queries, nested queries to create more complex views, you may find that the query The performance drops drastically. Therefore, before using complex views, you should test to ensure that their performance meets the needs of your application.

Use views.

````SQL
select * from `vw_student_score` order by `avg_score` desc;
````

````
+-------------+------------+
| stuname | avgscore |
+-------------+------------+
| Yang Guo | 95.6 |
| Let me go | 53.5 |
| Wang Yuyan | 84.3 |
| Ji Yanran | 73.8 |
| Yue Buqun | 78.0 |
| Eastern Unbeaten | 88.0 |
| Xiang Shaolong | 92.0 |
+-------------+------------+
````
Since the view is a virtual table, can the data in the view be updated? Updability of views is case-by-case, and the following types of views cannot be updated:

1. Aggregate functions (`SUM`, `MIN`, `MAX`, `AVG`, `COUNT`, etc.), `DISTINCT`, `GROUP BY`, `HAVING`, `UNION`, or `UNION ALL` are used view.
2. `SELECT` contains views of subqueries.
3. The `FROM` clause contains a view that cannot be updated.
4. The subquery of the `WHERE` clause references a view of the table in the `FROM` clause.

Delete the view.

````SQL
drop view vw_student_score;
````

> **Note**: If you want to update the view, you can delete the view first with the above command, or you can update the view through `create or replace view`.

View rules and restrictions.

1. Views can be nested, and a new view can be constructed using data retrieved from other views. Views can also be used with tables.
2. The `order by` clause can be used when creating a view, but if `order by` is also used when retrieving data from a view, the original `order by` in the view will be overwritten.
3. Views cannot use indexes, and they will not trigger the execution of triggers (in actual development, due to performance and other considerations, triggers are generally not recommended, so we will not introduce this concept).

#### functions

There are too many differences between functions in MySQL and functions in Python, because functions are used to encapsulate code that is relatively independent in function and will be reused. If you have to find some differences, then functions in MySQL can execute SQL statements. In the following example, we implement the function of truncating super-long strings through a custom function.

````SQL
delimiter $$

create function truncate_string(
    content varchar(10000),
    max_length int unsigned
) returns varchar(10000) no sql
begin
    declare result varchar(10000) default content;
    if char_length(content) > max_length then
        set result = left(content, max_length);
        set result = concat(result, '...');
    end if;
    return result;
end $$

delimiter;
````

> **Note 1**: The `no sql` after the function declaration is to declare that the function body does not use SQL statements; if the function body needs to read data through SQL, it needs to be declared as `reads sql data`.
>
> **Note 2**: The `delimiter` command before and after the function is defined to modify the delimiter, because the statements in the function body are all terminated with `;`. If the delimiter is not redefined, then the `;`, the code will be truncated and executed, obviously this is not the effect we want.

Call the custom function in the query.

````SQL
select truncate_string('Walk around the streets of Chengdu with me until all the lights go out', 10) as short_string;
````

````
+--------------------------------------+
| short_string |
+--------------------------------------+
| Walk with me on the streets of Chengdu... |
+--------------------------------------+
````

#### process

A procedure (also known as a stored procedure) is a collection of SQL compiled and stored in the database in advance. The calling procedure can simplify the work of application developers, reduce communication with the database server, and improve the performance of data operations. helpful. In fact, the SQL statements we have used so far are single statements for one or more tables, but in actual development, we often encounter situations where an operation requires multiple SQL statements to complete. For example, when an e-commerce website accepts user orders, it needs to do the following series of processing.

1. Check whether there are corresponding items in the inventory and whether the inventory is sufficient by querying.
2. If there are items in stock, lock the stock to ensure those items are no longer sold to others, and reduce the number of items available to reflect the correct stock level.
3. If inventory is insufficient, further interaction with the supplier may be required or at least a system prompt message may be generated.
4. Regardless of whether the order is successfully accepted or not, a flow record needs to be generated, and a notification message needs to be generated for the corresponding user.

We can encapsulate complex operations through processes, which not only helps to ensure data consistency, but also if the business changes in the future, we only need to adjust and modify the process. To the user calling the procedure, the procedure does not expose the details of the data table, and the execution of the procedure is much faster than executing a set of SQL one by one.

The following procedure implements a query for the highest, lowest, and average scores for a course.

````SQL
drop procedure if exists sp_score_stat;

delimiter $$

create procedure sp_score_stat(
courseId int,
out maxScore decimal(4,1),
out minScore decimal(4,1),
out avgScore decimal(4,1)
)
begin
select max(score) into maxScore from tb_record where cou_id=courseId;
select min(score) into minScore from tb_record where cou_id=courseId;
select avg(score) into avgScore from tb_record where cou_id=courseId;
end $$

delimiter;
````

> **Note**: When defining a procedure, since it may be necessary to write multiple SQLs, a semicolon needs to be used as a separator to separate these SQLs. If at this time, a semicolon is still used to indicate the end of the entire code, then the definition of the procedure SQL errors will occur, so above we use `delimiter $$` to define the end of the entire code as `$$`, then the semicolon in the code will no longer indicate the end of the entire code, the entire code will only Executed when `end $$` is encountered. After defining the procedure, change the terminator back to a semicolon via `delimiter ;` (restore the scene).

The process defined above has four parameters. The first parameter is the input parameter, which represents the number of the course, and the following parameters are output parameters, because the process cannot define the return value, and the execution result can only be brought out through the output parameter. The keyword for output parameters is `out`, and the parameters are input parameters by default.

call procedure.

````SQL
call sp_score_stat(1111, @a, @b, @c);
````

Get the value of the output parameter.

````SQL
select @a as highest score, @b as lowest score, @c as average score;
````

delete process.

````SQL
drop procedure sp_score_stat;
````

In the process, we can define variables and conditions, use branch and loop statements, query results through cursor operations, and use event schedulers, which we will not introduce here for the time being. Although we have talked about the benefits of many processes, in actual development, if the process is frequently used and a large number of complex operations are put into the process, it will cause huge pressure on the database server, and the database is often the performance bottleneck. The use process is undoubtedly a worse operation. Therefore, for Internet product development, we generally recommend that the database is only stored, and the complex calculation and processing are left to the program on the application server to complete. If the application server becomes overwhelmed, we can easily deploy multiple applications. Servers to share these pressures.

If you are interested in the views, functions, and procedures mentioned above, including triggers that we have not mentioned, I suggest you read the MySQL introductory book ["MySQL must know and know"](https://item.jd. com/12818982.html) for general understanding, because these knowledge points may not be used in your future work, and you may learn them just to cope with the interview.

### MySQL New Features

#### JSON type

When many developers use relational databases for data persistence, they often feel that structured storage lacks flexibility, because all columns and corresponding data types must be designed in advance. In the process of business development and changes, if you need to modify the table structure, it is definitely more troublesome and uncomfortable. Since MySQL version 5.7, MySQL has introduced support for JSON data type (MySQL 8.0 solved the JSON log performance bottleneck). Using JSON type well is actually breaking the boundaries between relational databases and non-relational databases. It brings more convenience to data persistence operations.

JSON types are mainly divided into JSON objects and JSON arrays, as shown below.

1. JSON object

````JSON
{"name": "Luo Hao", "tel": "13122335566", "QQ": "957658"}
````

2. JSON array

````JSON
[1, 2, 3]
````

````JSON
[{"name": "Luo Hao", "tel": "13122335566"}, {"name": "Wang Dahui", "QQ": "123456"}]
````

Where do you need to use the JSON type? To give a simple example, users of many products now support multiple ways to log in, such as mobile phone numbers, WeChat, QQ, Sina Weibo, etc. However, under normal circumstances, we do not require users to provide all of this information, so use traditional , you need to design multiple columns to correspond to multiple login methods, and you may also need to allow null values ​​in these columns, which is obviously not a good choice; on the other hand, if the product adds another login method, then It is necessary to modify the previous table structure, which is even more painful. However, with the JSON type, the problem just now is solved, and we can make the design as shown below.

````SQL
create table `tb_test`
(
`user_id` bigint unsigned,
`login_info` json,
primary key (`user_id`)
) engine=innodb;

insert into `tb_test` values
    (1, '{"tel": "13122335566", "QQ": "654321", "wechat": "jackfrued"}'),
    (2, '{"tel": "13599876543", "weibo": "wangdachui123"}');
````

If you want to query the user's mobile phone and WeChat account, you can use the following SQL statement.

````SQL
select
    `user_id`,
    json_unquote(json_extract(`login_info`, '$.tel')) as phone number,
    json_unquote(json_extract(`login_info`, '$.wechat')) as WeChat
from `tb_test`;
````

````
+---------+-------------+------------+
| user_id | Mobile number | WeChat |
+---------+-------------+------------+
| 1 | 13122335566 | jackfrued |
|2|13599876543|NULL|
+---------+-------------+------------+
````

Because of its support for JSON types, MySQL also provides supporting functions for processing JSON data, such as `json_extract` and `json_unquote` used above. Of course, there is a more convenient way to write the above SQL, as shown below.

````SQL
select
`user_id`,
    `login_info` ->> '$.tel' as phone number,
    `login_info` ->> '$.wechat' as WeChat
from `tb_test`;
````

For another example, if our product wants to implement the user portrait function (labeling users), and then recommend platform services or consumer goods to users based on user portraits, we can also use JSON type to save user portrait data, The schematic code is shown below.

Create a portrait tag table.

````SQL
create table `tb_tags`
(
`tag_id` int unsigned not null comment 'tag_id',
`tag_name` varchar(20) not null comment 'tag name',
primary key (`tag_id`)
) engine=innodb;

insert into `tb_tags` (`tag_id`, `tag_name`)
values
    (1, 'after 70'),
    (2, 'After 80'),
    (3, 'Post-90'),
    (4, 'after 00'),
    (5, 'Love sports'),
    (6, 'Highly educated'),
    (7, 'petty bourgeoisie'),
    (8, 'Have a room'),
    (9, 'has a car'),
    (10, 'I love watching movies'),
    (11, 'Love online shopping'),
    (12, 'Frequently order takeaway');
````

Tag users.

````SQL
create table `tb_users_tags`
(
`user_id` bigint unsigned not null comment 'user_id',
`user_tags` json not null comment 'user tags'
) engine=innodb;

insert into `tb_users_tags` values
    (1, '[2, 6, 8, 10]'),
    (2, '[3, 10, 12]'),
    (3, '[3, 8, 9, 11]');
````

Next, let's take a look at the ingenuity of the JSON type through a set of queries.

1. Find the user ID of the movie lover (with the tag `10`).

    ````SQL
    select * from `tb_users` where 10 member of (user_tags->'$');
    ````

2. Query the user IDs of the post-80s generation (with the tag `2`) who like to watch movies (with the tag `10`).

    ````
    select * from `tb_users` where json_contains(user_tags->'$', '[2, 10]');

3. Inquire about the user IDs who like to watch movies or those born in the 1980s or 1990s.

    ````SQL
    select `user_id` from `tb_users_tags` where json_overlaps(user_tags->'$', '[2, 3, 10]');
    ````

> **Note**: The above query uses the `member of` predicate and two JSON functions, `json_contains` can check whether the JSON array contains the specified element, and `json_overlaps` can check whether the JSON array is the same as the specified array There are overlapping parts.

#### window functions

MySQL has supported window functions since 8.0. Most commercial databases and some open source databases have already provided support for window functions, and some also call them OLAP (Online Analysis and Processing) functions. related. In order to help you understand window functions, let's talk about the concept of windows first.

A window can be understood as a collection of records, and a window function is a special function that is executed on a collection of records that meet certain conditions. For each record, the function must be executed in this window. The window function and the aggregation function we mentioned above are easy to confuse. The main difference between the two is that the aggregation function aggregates multiple records into one record, and the window function is executed for each record, and the number of records will not change after execution. The window function is not just a few functions, it is a complete set of syntax, the function is only a part of the syntax, the basic syntax is as follows:

````SQL
<window function> over (partition by <column name for grouping> order by <column name for user sorting>)
````

In the above syntax, the following two functions can be placed in the position of the window function:

1. Dedicated window functions, including: `lead`, `lag`, `first_value`, `last_value`, `rank`, `dense_rank` and `row_number`, etc.
2. Aggregate functions, including: `sum`, `avg`, `max`, `min` and `count`, etc.

Here are a few simple examples of using window functions. We first use the following SQL to build a database and build a table.

````SQL
-- Create a database named hrs and specify the default character set
create database `hrs` default charset utf8mb4;

-- switch to hrs database
use `hrs`;

-- create department table
create table `tb_dept`
(
`dno` int not null comment 'Number',
`dname` varchar(10) not null comment 'name',
`dloc` varchar(20) not null comment 'Location',
primary key (`dno`)
);

-- insert 4 departments
insert into `tb_dept` values
    (10, 'Accounting Department', 'Beijing'),
    (20, 'R&D Department', 'Chengdu'),
    (30, 'Sales Department', 'Chongqing'),
    (40, 'Operation and Maintenance Department', 'Shenzhen');

-- create employee table
create table `tb_emp`
(
`eno` int not null comment 'employee number',
`ename` varchar(20) not null comment 'employee name',
`job` varchar(20) not null comment 'employee position',
`mgr` int comment 'Supervisor number',
`sal` int not null comment 'Employee monthly salary',
`comm` int comment 'Monthly allowance',
`dno` int not null comment 'Department number',
primary key (`eno`),
constraint `fk_emp_mgr` foreign key (`mgr`) references tb_emp (`eno`),
constraint `fk_emp_dno` foreign key (`dno`) references tb_dept (`dno`)
);

-- Insert 14 employees
insert into `tb_emp` values
    (7800, 'Zhang Sanfeng', 'President', null, 9000, 1200, 20),
    (2056, 'Qiao Feng', 'Analyst', 7800, 5000, 1500, 20),
    (3088, 'Li Mochou', 'Designer', 2056, 3500, 800, 20),
    (3211, 'Zhang Wuji', 'Programmer', 2056, 3200, null, 20),
    (3233, 'Qiu Chuji', 'programmer', 2056, 3400, null, 20),
    (3251, 'Zhang Cuishan', 'programmer', 2056, 4000, null, 20),
    (5566, 'Song Yuanqiao', 'Accountant', 7800, 4000, 1000, 10),
    (5234, 'Guo Jing', 'Cashier', 5566, 2000, null, 10),
    (3344, 'Huang Rong', 'Sales Supervisor', 7800, 3000, 800, 30),
    (1359, 'Hu Yidao', 'Salesman', 3344, 1800, 200, 30),
    (4466, 'Miao Renfeng', 'Salesman', 3344, 2500, null, 30),
    (3244, 'Ouyang Feng', 'Programmer', 3088, 3200, null, 20),
    (3577, 'Yang Guo', 'Accounting', 5566, 2200, null, 10),
    (3588, 'Zhu Jiuzhen', 'Accounting', 5566, 2500, null, 10);
````

Example 1: Query the names and monthly salaries of employees ranked 4th to 6th in descending order of monthly salary.

````SQL
select * from (
select
`ename`, `sal`,
row_number() over (order by `sal` desc) as `rank`
from `tb_emp`
) `temp` where `rank` between 4 and 6;
````

> **Note**: The function `row_number()` used above can generate a row number for each record, in actual work, it can be replaced with the `rank()` or `dense_rank()` function as needed, The difference between the three can be understood by referring to the official documents or reading ["Easy to Understand: SQL Window Functions"](https://zhuanlan.zhihu.com/p/92654574). In versions prior to MySQL 8, we could do something similar in the following way.
>
> ````SQL
> select `rank`, `ename`, `sal` from (
> select @a:=@a+1 as `rank`, `ename`, `sal`
> from `tb_emp`, (select @a:=0) as t1 order by `sal` desc
> ) t2 where `rank` between 4 and 6;
> ````

Example 2: Query the names and department names of the two employees with the highest monthly salary in each department.

````SQL
select `ename`, `sal`, `dname`
from (
    select
        `ename`, `sal`, `dno`,
        rank() over (partition by `dno` order by `sal` desc) as `rank`
    from `tb_emp`
) as `temp` natural join `tb_dept` where `rank`<=2;
````

> Description: In versions prior to MySQL 8, we can accomplish similar operations in the following ways.
>
> ````SQL
> select `ename`, `sal`, `dname` from `tb_emp` as `t1`
natural join `tb_dept`
where (
    select count(*) from `tb_emp` as `t2`
    where `t1`.`dno`=`t2`.`dno` and `t2`.`sal`>`t1`.`sal`
)<2 order by `dno` asc, `sal` desc;
> ````

###  Other content

#### Paradigm Theory

Paradigm theory is the guiding ideology for designing two-dimensional tables in relational databases.

1. First Normal Form: The value range of each column of the data table is composed of atomic values, which cannot be further divided.
2. Second normal form: All data in the data table must be completely dependent on the keys (primary key and candidate key) of the data table.
3. Third Normal Form: All non-key attributes are only related to candidate keys, that is to say, non-key attributes should be independent and unrelated.

> **Note**: In actual work, for the sake of efficiency, we are likely to make anti-paradigm design when designing tables, that is, deliberately reduce the mode level and add redundant data to obtain better operation performance.

#### Data Integrity

1. Entity Integrity - each entity is unique

   - primary key (`primary key`) / unique constraint (`unique`)
2. Referential Integrity (Referential Integrity) - References to non-existent entities are not allowed in the relationship

   - foreign key (`foreign key`)
3. Domain integrity - data is valid
   - data type and length

   - Not null constraint (`not null`)

   - default value constraint (`default`)

   - check constraints (`check`)

     > **Note**: Before MySQL 8.x, check constraints did not work.

#### Data Consistency

1. Transaction: A series of read/write operations to the database that either all succeed or all fail.

2. ACID properties of transactions
   - Atomicity: The transaction is executed as a whole, and either all or none of the operations on the database involved in it are executed
   - Consistency: Transactions should ensure that the state of the database changes from one consistent state to another consistent state
   - Isolation: When multiple transactions are executed concurrently, the execution of one transaction should not affect the execution of other transactions
   - Persistence: Modifications to the database by committed transactions should be permanently stored in the database

3. Transaction Operations in MySQL

   - Open transaction environment

     ````SQL
     start transaction
     ````

   - Commit transaction

     ````SQL
     commit
     ````

   - rollback transaction

     ````SQL
     rollback
     ````

4. Check the transaction isolation level

    ````SQL
    show variables like 'transaction_isolation';
    ````

    ````
    +----------------------+-----------------+
    | Variable_name | Value |
    +----------------------+-----------------+
    | transaction_isolation | REPEATABLE-READ |
    +----------------------+-----------------+
    ````

    It can be seen that MySQL's default transaction isolation level is `REPEATABLE-READ`.

5. Modify the (current session) transaction isolation level

    ````SQL
    set session transaction isolation level read committed;
    ````

    Re-check the transaction isolation level and the result is as follows.

    ````
    +----------------------+----------------+
    | Variable_name | Value |
    +----------------------+----------------+
    | transaction_isolation | READ-COMMITTED |
    +----------------------+----------------+
    ````

Transactions in relational databases are a big topic, because when there are multiple concurrent transactions accessing data, there may be three types of data read problems (dirty read, non-repeatable read, phantom read) and two types of update data. Problems (type 1 missing updates, type 2 missing updates). If you want to understand these five types of questions, you can read the first part of the article ["Java Interview Questions (Part 1)"](https://blog.csdn.net/jackfrued/article/details/44921941) published on the CSDN website 80 questions. In order to avoid these problems, the bottom layer of relational databases has a corresponding locking mechanism, which can be divided into table-level locks and row-level locks according to different lock objects, and shared locks and exclusive locks according to concurrent transaction locking relationships. However, it is very troublesome to use locks directly. For this reason, the database provides an automatic locking mechanism for users. As long as the user specifies an appropriate transaction isolation level, the database will analyze the SQL statement and then add appropriate locks to the resources accessed by the transaction. In addition, the database will maintain these locks to improve the performance of the system through various means, which are transparent to the user. If you want to know the details of MySQL transactions and locks, I recommend everyone to read the advanced book ["High Performance MySQL"](https://item.jd.com/11220393.html), which is also a classic book on databases.

The ANSI/ISO SQL 92 standard defines four levels of transaction isolation levels, as shown in the following table. It should be noted that the transaction isolation level and the concurrency of data access are opposite, the higher the transaction isolation level, the worse the concurrency. Therefore, it is necessary to determine which transaction isolation level to use according to the specific application. There is no universal principle in this place.

<img src="https://gitee.com/jackfrued/mypic/raw/master/20211121225327.png" style="zoom:50%;">

### Summarize

The knowledge about SQL and MySQL is definitely far more than those listed above, such as the optimization of SQL itself, MySQL performance tuning, MySQL operation and maintenance related tools, MySQL data backup and recovery, monitoring MySQL services, deploying high-availability architectures, etc. There is no way to discuss this series of issues one by one here, so I will leave it to explain when necessary, and readers can also explore on their own.
